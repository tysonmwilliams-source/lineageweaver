import { useState, useEffect, useRef } from 'react';
import * as d3 from 'd3';
import { getAllPeople, getAllHouses, getAllRelationships, updatePerson } from '../services/database';
import Navigation from '../components/Navigation';
import TreeControls from '../components/TreeControls';
import QuickEditPanel from '../components/QuickEditPanel';
import { calculateAllRelationships } from '../utils/RelationshipCalculator';
import { useTheme } from '../components/ThemeContext';
import { getAllThemeColors, getHouseColor } from '../utils/themeColors';

function FamilyTree() {
  // Use the global theme system
  const { theme, isDarkTheme } = useTheme();

  const [people, setPeople] = useState([]);
  const [houses, setHouses] = useState([]);
  const [relationships, setRelationships] = useState([]);
  const [selectedHouseId, setSelectedHouseId] = useState(null);
  const [loading, setLoading] = useState(true);
  const [showCadetHouses, setShowCadetHouses] = useState(true);
  const [zoomLevel, setZoomLevel] = useState(1);
  const svgRef = useRef(null);
  const zoomBehaviorRef = useRef(null);

  // BATCH 1: Search functionality
  const [searchResults, setSearchResults] = useState([]);
  
  // BATCH 1: Quick edit panel
  const [selectedPerson, setSelectedPerson] = useState(null);
  
  // BATCH 1: Relationship calculator
  const [showRelationships, setShowRelationships] = useState(false);
  const [referencePerson, setReferencePerson] = useState(null);
  const [relationshipMap, setRelationshipMap] = useState(new Map());
  const showRelationshipsRef = useRef(false);
  
  // Controls panel collapse state
  const [controlsPanelExpanded, setControlsPanelExpanded] = useState(true);

  const CARD_WIDTH = 150;
  const CARD_HEIGHT = 70;
  const SPACING = 35;
  const VERTICAL_SPACING = 150;
  const ANCHOR_X = 1500;
  const START_Y = 100;
  const GROUP_SPACING = 50;

  // Note: Now using getAllThemeColors() utility from themeColors.js

  // Helper function to harmonize house colors with current theme
  const harmonizeColor = (hexColor) => {
    const hex = hexColor.replace('#', '');
    let r = parseInt(hex.substr(0, 2), 16);
    let g = parseInt(hex.substr(2, 2), 16);
    let b = parseInt(hex.substr(4, 2), 16);

    if (isDarkTheme()) {
      const warmBrown = { r: 120, g: 100, b: 80 };
      const desaturationAmount = 0.5;
      r = Math.round(r * (1 - desaturationAmount) + warmBrown.r * desaturationAmount);
      g = Math.round(g * (1 - desaturationAmount) + warmBrown.g * desaturationAmount);
      b = Math.round(b * (1 - desaturationAmount) + warmBrown.b * desaturationAmount);
      const darkenAmount = 0.7;
      r = Math.round(r * darkenAmount);
      g = Math.round(g * darkenAmount);
      b = Math.round(b * darkenAmount);
    } else {
      const warmCream = { r: 180, g: 160, b: 140 };
      const desaturationAmount = 0.4;
      r = Math.round(r * (1 - desaturationAmount) + warmCream.r * desaturationAmount);
      g = Math.round(g * (1 - desaturationAmount) + warmCream.g * desaturationAmount);
      b = Math.round(b * (1 - desaturationAmount) + warmCream.b * desaturationAmount);
      const adjustAmount = 0.8;
      r = Math.round(r * adjustAmount);
      g = Math.round(g * adjustAmount);
      b = Math.round(b * adjustAmount);
    }

    const toHex = (n) => {
      const hex = n.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  };

  useEffect(() => { loadData(); }, []);

  useEffect(() => {
    if (selectedHouseId && people.length > 0) drawTree();
  }, [selectedHouseId, people, houses, relationships, showCadetHouses, theme, searchResults, relationshipMap]);

  const loadData = async () => {
    try {
      setLoading(true);
      const [allPeople, allHouses, allRelationships] = await Promise.all([
        getAllPeople(), getAllHouses(), getAllRelationships()
      ]);
      setPeople(allPeople);
      setHouses(allHouses);
      setRelationships(allRelationships);
      if (allHouses.length > 0 && !selectedHouseId) setSelectedHouseId(allHouses[0].id);
    } catch (error) {
      console.error('Error loading data:', error);
      alert('Failed to load data.');
    } finally {
      setLoading(false);
    }
  };

  const handleSearchResults = (results) => {
    setSearchResults(results);
  };

  const handlePersonClick = (person) => {
    setSelectedPerson(person);
    
    if (showRelationshipsRef.current) {
      setReferencePerson(person);
      const { parentMap, childrenMap, spouseMap } = buildRelationshipMaps();
      const relationships = calculateAllRelationships(person.id, people, parentMap, childrenMap, spouseMap);
      setRelationshipMap(relationships);
    }
  };

  const handleQuickSave = async (personData) => {
    try {
      await updatePerson(personData.id, personData);
      setSelectedPerson(null);
      loadData();
    } catch (error) {
      alert('Error saving: ' + error.message);
    }
  };

  const handleFullEdit = (person) => {
    setSelectedPerson(null);
    alert('Full edit modal not yet implemented. Use Manage page for now.');
  };

  const buildRelationshipMaps = () => {
    const peopleById = new Map(people.map(p => [p.id, p]));
    const housesById = new Map(houses.map(h => [h.id, h]));
    const parentMap = new Map();
    const childrenMap = new Map();
    const spouseMap = new Map();

    relationships.forEach(rel => {
      if (rel.relationshipType === 'spouse') {
        if (peopleById.has(rel.person1Id) && peopleById.has(rel.person2Id)) {
          spouseMap.set(rel.person1Id, rel.person2Id);
          spouseMap.set(rel.person2Id, rel.person1Id);
        }
      } else if (rel.relationshipType === 'parent' || rel.relationshipType === 'adopted-parent') {
        const parentId = rel.person1Id;
        const childId = rel.person2Id;
        if (!parentMap.has(childId)) parentMap.set(childId, []);
        parentMap.get(childId).push(parentId);
        if (!childrenMap.has(parentId)) childrenMap.set(parentId, []);
        childrenMap.get(parentId).push(childId);
      }
    });

    return { peopleById, housesById, parentMap, childrenMap, spouseMap };
  };

  const drawPersonCard = (g, person, x, y, housesById, themeColors) => {
    const birthHouse = housesById.get(person.houseId);
    const originalColor = birthHouse ? birthHouse.colorCode : '#666666';
    const harmonizedBg = harmonizeColor(originalColor);
    
    let borderColor = themeColors.statusBorders.legitimate;
    if (person.legitimacyStatus === 'bastard') borderColor = themeColors.statusBorders.bastard;
    if (person.legitimacyStatus === 'adopted') borderColor = themeColors.statusBorders.adopted;

    const card = g.append('g')
      .attr('class', 'person-card')
      .attr('transform', `translate(${x}, ${y})`)
      .style('cursor', 'pointer')
      .on('click', () => handlePersonClick(person));
    
    card.append('rect')
      .attr('width', CARD_WIDTH)
      .attr('height', CARD_HEIGHT)
      .attr('fill', harmonizedBg)
      .attr('stroke', borderColor)
      .attr('stroke-width', 2.5)
      .attr('rx', 6);
    
    const glowColor = isDarkTheme() ? 'rgba(233, 220, 201, 0.1)' : 'rgba(255, 255, 255, 0.3)';
    card.append('rect')
      .attr('x', 1).attr('y', 1)
      .attr('width', CARD_WIDTH - 2).attr('height', CARD_HEIGHT - 2)
      .attr('fill', 'none').attr('stroke', glowColor).attr('stroke-width', 1).attr('rx', 5);
    
    card.append('text')
      .attr('x', CARD_WIDTH / 2).attr('y', 22)
      .attr('text-anchor', 'middle').attr('class', 'person-name')
      .attr('fill', '#e9dcc9')
      .text(`${person.firstName} ${person.lastName}`);
    
    let currentY = 22;
    if (person.maidenName) {
      currentY += 15;
      card.append('text')
        .attr('x', CARD_WIDTH / 2).attr('y', currentY)
        .attr('text-anchor', 'middle').attr('class', 'person-maiden')
        .attr('fill', '#b8a891')
        .text(`(née ${person.maidenName})`);
    }
    currentY += 18;
    const dates = `b. ${person.dateOfBirth}${person.dateOfDeath ? ` - d. ${person.dateOfDeath}` : ''}`;
    card.append('text')
      .attr('x', CARD_WIDTH / 2).attr('y', currentY)
      .attr('text-anchor', 'middle').attr('class', 'person-dates')
      .attr('fill', '#b8a891')
      .text(dates);

    const isHighlighted = searchResults.some(p => p.id === person.id);
    if (isHighlighted) {
      card.append('rect')
        .attr('width', CARD_WIDTH)
        .attr('height', CARD_HEIGHT)
        .attr('fill', 'none')
        .attr('stroke', '#ffff00')
        .attr('stroke-width', 3)
        .attr('rx', 6)
        .attr('class', 'search-highlight');
    }
    
    if (showRelationships && relationshipMap.has(person.id)) {
      const relationship = relationshipMap.get(person.id);
      card.append('rect')
        .attr('x', 5)
        .attr('y', CARD_HEIGHT - 20)
        .attr('width', CARD_WIDTH - 10)
        .attr('height', 16)
        .attr('fill', 'rgba(0, 0, 0, 0.7)')
        .attr('rx', 3);
      
      card.append('text')
        .attr('x', CARD_WIDTH / 2)
        .attr('y', CARD_HEIGHT - 8)
        .attr('text-anchor', 'middle')
        .attr('fill', '#ffffff')
        .attr('font-size', '10px')
        .attr('font-weight', 'bold')
        .text(relationship);
    }
    
    return { x, y, width: CARD_WIDTH, height: CARD_HEIGHT, personId: person.id };
  };

  const drawMarriageLine = (g, pos1, pos2, themeColors) => {
    const x1 = pos1.x + pos1.width;
    const y1 = pos1.y + (pos1.height / 2);
    const x2 = pos2.x;
    const y2 = pos2.y + (pos2.height / 2);
    
    // Use a muted color for marriage lines
    const marriageColor = isDarkTheme() ? '#c08a7a' : '#b87a8a';
    
    g.append('line').attr('class', 'marriage-line')
      .attr('x1', x1).attr('y1', y1).attr('x2', x2).attr('y2', y2)
      .attr('stroke', marriageColor);
    return { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
  };

  const drawChildLines = (g, marriageCenter, positions, parentY, childY, peopleById, themeColors, yOffset = 0, parentId = null, spouseId = null) => {
    if (positions.length === 0) return;
    const midY = parentY + (childY - parentY) / 2;
    
    const legitimateChildren = [];
    const bastardChildren = [];
    const adoptedChildren = [];
    
    positions.forEach(pos => {
      const person = peopleById.get(pos.personId);
      if (person) {
        if (person.legitimacyStatus === 'bastard') {
          bastardChildren.push(pos);
        } else if (person.legitimacyStatus === 'adopted') {
          adoptedChildren.push(pos);
        } else {
          legitimateChildren.push(pos);
        }
      }
    });

    const lineSystemsCount = [legitimateChildren.length > 0, bastardChildren.length > 0, adoptedChildren.length > 0].filter(Boolean).length;
    
    let legitOffset = 0;
    let bastardOffset = 0;
    let adoptedOffset = 0;
    
    if (lineSystemsCount === 1) {
      legitOffset = bastardOffset = adoptedOffset = 0;
    } else if (lineSystemsCount === 2) {
      if (legitimateChildren.length > 0 && bastardChildren.length > 0) {
        legitOffset = 2.5;
        bastardOffset = -2.5;
      } else if (legitimateChildren.length > 0 && adoptedChildren.length > 0) {
        legitOffset = -2.5;
        adoptedOffset = 2.5;
      } else if (bastardChildren.length > 0 && adoptedChildren.length > 0) {
        bastardOffset = -2.5;
        adoptedOffset = 2.5;
      }
    } else if (lineSystemsCount === 3) {
      bastardOffset = -5;
      legitOffset = 0;
      adoptedOffset = 5;
    }

    if (legitimateChildren.length > 0) {
      const legitFirstX = legitimateChildren[0].x + CARD_WIDTH / 2;
      const legitLastX = legitimateChildren[legitimateChildren.length - 1].x + CARD_WIDTH / 2;
      const legitCenterX = (legitFirstX + legitLastX) / 2;
      const legitMarriageX = marriageCenter.x + legitOffset;
      const legitY = midY + yOffset;

      g.append('line').attr('class', 'child-line-legit').attr('stroke', themeColors.lines.legitimate).attr('stroke-width', 2).attr('x1', legitMarriageX).attr('y1', marriageCenter.y).attr('x2', legitMarriageX).attr('y2', legitY);
      g.append('line').attr('class', 'child-line-legit').attr('stroke', themeColors.lines.legitimate).attr('stroke-width', 2).attr('x1', legitMarriageX).attr('y1', legitY).attr('x2', legitCenterX).attr('y2', legitY);
      g.append('line').attr('class', 'child-line-legit').attr('stroke', themeColors.lines.legitimate).attr('stroke-width', 2).attr('x1', legitFirstX).attr('y1', legitY).attr('x2', legitLastX).attr('y2', legitY);
      legitimateChildren.forEach(pos => {
        g.append('line').attr('class', 'child-line-legit').attr('stroke', themeColors.lines.legitimate).attr('stroke-width', 2).attr('x1', pos.x + CARD_WIDTH / 2).attr('y1', legitY).attr('x2', pos.x + CARD_WIDTH / 2).attr('y2', pos.y);
      });
    }

    if (bastardChildren.length > 0) {
      const bastardFirstX = bastardChildren[0].x + CARD_WIDTH / 2;
      const bastardLastX = bastardChildren[bastardChildren.length - 1].x + CARD_WIDTH / 2;
      const bastardCenterX = (bastardFirstX + bastardLastX) / 2;
      const bastardY = midY - 5 + yOffset;
      
      let bastardMarriageX = marriageCenter.x + bastardOffset;
      let bastardStartY = marriageCenter.y;
      
      if (!spouseId && parentId) {
        const parent = peopleById.get(parentId);
        if (parent) {
          bastardMarriageX = marriageCenter.x + bastardOffset;
          bastardStartY = parentY;
        }
      }

      g.append('line').attr('class', 'child-line-bastard').attr('stroke', themeColors.lines.bastard).attr('stroke-width', 2).attr('x1', bastardMarriageX).attr('y1', bastardStartY).attr('x2', bastardMarriageX).attr('y2', bastardY);
      g.append('line').attr('class', 'child-line-bastard').attr('stroke', themeColors.lines.bastard).attr('stroke-width', 2).attr('x1', bastardMarriageX).attr('y1', bastardY).attr('x2', bastardCenterX).attr('y2', bastardY);
      g.append('line').attr('class', 'child-line-bastard').attr('stroke', themeColors.lines.bastard).attr('stroke-width', 2).attr('x1', bastardFirstX).attr('y1', bastardY).attr('x2', bastardLastX).attr('y2', bastardY);
      bastardChildren.forEach(pos => {
        g.append('line').attr('class', 'child-line-bastard').attr('stroke', themeColors.lines.bastard).attr('stroke-width', 2).attr('x1', pos.x + CARD_WIDTH / 2).attr('y1', bastardY).attr('x2', pos.x + CARD_WIDTH / 2).attr('y2', pos.y);
      });
    }

    if (adoptedChildren.length > 0) {
      const adoptedFirstX = adoptedChildren[0].x + CARD_WIDTH / 2;
      const adoptedLastX = adoptedChildren[adoptedChildren.length - 1].x + CARD_WIDTH / 2;
      const adoptedCenterX = (adoptedFirstX + adoptedLastX) / 2;
      const adoptedMarriageX = marriageCenter.x + adoptedOffset;
      const adoptedY = midY + 5 + yOffset;

      g.append('line').attr('class', 'child-line-adopted').attr('stroke', themeColors.lines.adopted).attr('stroke-width', 2).attr('x1', adoptedMarriageX).attr('y1', marriageCenter.y).attr('x2', adoptedMarriageX).attr('y2', adoptedY);
      g.append('line').attr('class', 'child-line-adopted').attr('stroke', themeColors.lines.adopted).attr('stroke-width', 2).attr('x1', adoptedMarriageX).attr('y1', adoptedY).attr('x2', adoptedCenterX).attr('y2', adoptedY);
      g.append('line').attr('class', 'child-line-adopted').attr('stroke', themeColors.lines.adopted).attr('stroke-width', 2).attr('x1', adoptedFirstX).attr('y1', adoptedY).attr('x2', adoptedLastX).attr('y2', adoptedY);
      adoptedChildren.forEach(pos => {
        g.append('line').attr('class', 'child-line-adopted').attr('stroke', themeColors.lines.adopted).attr('stroke-width', 2).attr('x1', pos.x + CARD_WIDTH / 2).attr('y1', adoptedY).attr('x2', pos.x + CARD_WIDTH / 2).attr('y2', pos.y);
      });
    }
  };

  const drawTree = () => {
    // Get current theme colors using utility function
    const themeColors = getAllThemeColors();
    
    let savedTransform = null;
    const existingGroup = d3.select(svgRef.current).select('.zoom-group');
    if (!existingGroup.empty()) {
      const transformStr = existingGroup.attr('transform');
      if (transformStr) {
        savedTransform = d3.zoomTransform(existingGroup.node());
      }
    }

    d3.select(svgRef.current).selectAll('*').remove();
    const { peopleById, housesById, parentMap, childrenMap, spouseMap } = buildRelationshipMaps();
    
    const svg = d3.select(svgRef.current).attr('width', '100%').attr('height', '100%');
    const g = svg.append('g').attr('class', 'zoom-group');

    const zoom = d3.zoom().scaleExtent([0.1, 3])
      .on('zoom', (event) => { g.attr('transform', event.transform); setZoomLevel(event.transform.k); });

    svg.call(zoom);
    zoomBehaviorRef.current = zoom;
    
    const initialTransform = savedTransform || d3.zoomIdentity.translate(200, 100).scale(0.8);
    svg.call(zoom.transform, initialTransform);

    g.append('line').attr('class', 'anchor-line')
      .attr('x1', ANCHOR_X).attr('y1', 0).attr('x2', ANCHOR_X).attr('y2', 1500)
      .attr('stroke', themeColors.lines.anchor);

    if (people.length === 0) {
      g.append('text').attr('x', ANCHOR_X).attr('y', 200).attr('text-anchor', 'middle').attr('font-size', '20px').attr('fill', '#e9dcc9').text('No data available.');
      return;
    }

    const marriageLinesToDraw = [];
    const rootCandidates = Array.from(peopleById.values()).filter(p => !parentMap.has(p.id) && spouseMap.has(p.id));
    if (rootCandidates.length === 0) {
      g.append('text').attr('x', ANCHOR_X).attr('y', 200).attr('text-anchor', 'middle').attr('font-size', '20px').attr('fill', '#e9dcc9').text('No root couple found.');
      return;
    }
    
    rootCandidates.sort((a, b) => parseInt(a.dateOfBirth) - parseInt(b.dateOfBirth));
    const gen0P1 = rootCandidates[0];
    const gen0P2 = peopleById.get(spouseMap.get(gen0P1.id));
    
    if (!gen0P2) {
      g.append('text').attr('x', ANCHOR_X).attr('y', 200).attr('text-anchor', 'middle').attr('font-size', '20px').attr('fill', '#e9dcc9').text('Root spouse not found.');
      return;
    }

    // GEN 0
    const gen0Width = 2 * CARD_WIDTH + SPACING;
    const gen0StartX = ANCHOR_X - (gen0Width / 2);
    const gen0Pos1 = drawPersonCard(g, gen0P1, gen0StartX, START_Y, housesById, themeColors);
    const gen0Pos2 = drawPersonCard(g, gen0P2, gen0StartX + CARD_WIDTH + SPACING, START_Y, housesById, themeColors);
    const gen0MC = { x: (gen0Pos1.x + gen0Pos1.width + gen0Pos2.x) / 2, y: (gen0Pos1.y + gen0Pos1.height/2 + gen0Pos2.y + gen0Pos2.height/2) / 2 };
    marriageLinesToDraw.push([gen0Pos1, gen0Pos2]);

    // GEN 1
    const gen1Y = START_Y + CARD_HEIGHT + VERTICAL_SPACING;
    const gen1ChildIds = new Set([...(childrenMap.get(gen0P1.id) || []), ...(childrenMap.get(gen0P2.id) || [])]);
    const gen1Children = Array.from(gen1ChildIds).map(id => peopleById.get(id)).filter(p => p).sort((a, b) => parseInt(a.dateOfBirth) - parseInt(b.dateOfBirth));
    
    let gen1TotalCards = 0;
    gen1Children.forEach(c => { 
      gen1TotalCards++;
      const spouseId = spouseMap.get(c.id);
      if (spouseId && peopleById.has(spouseId)) gen1TotalCards++;
    });
    
    const gen1Width = gen1TotalCards * CARD_WIDTH + (gen1TotalCards - 1) * SPACING;
    let currentX = ANCHOR_X - (gen1Width / 2);
    const gen1Positions = [];
    
    gen1Children.forEach(person => {
      const personPos = drawPersonCard(g, person, currentX, gen1Y, housesById, themeColors);
      gen1Positions.push(personPos);
      currentX += CARD_WIDTH + SPACING;
      
      const spouseId = spouseMap.get(person.id);
      if (spouseId) {
        const spouse = peopleById.get(spouseId);
        if (spouse) {
          const spousePos = drawPersonCard(g, spouse, currentX, gen1Y, housesById, themeColors);
          marriageLinesToDraw.push([personPos, spousePos]);
          currentX += CARD_WIDTH + SPACING;
        }
      }
    });
    
    drawChildLines(g, gen0MC, gen1Positions, START_Y + CARD_HEIGHT, gen1Y, peopleById, themeColors, 0, gen0P1.id, gen0P2.id);

    const positionMap = new Map();
    const marriageCenters = new Map();
    positionMap.set(gen0P1.id, gen0Pos1);
    positionMap.set(gen0P2.id, gen0Pos2);
    marriageCenters.set([gen0P1.id, gen0P2.id].sort().join('-'), gen0MC);
    gen1Children.forEach((person, i) => {
      positionMap.set(person.id, gen1Positions[i]);
      const spouseId = spouseMap.get(person.id);
      if (spouseId && peopleById.has(spouseId)) {
        marriageCenters.set([person.id, spouseId].sort().join('-'), { x: (gen1Positions[i].x + CARD_WIDTH + SPACING/2), y: gen1Y + CARD_HEIGHT/2 });
      }
    });

    // GEN 2
    const gen2Y = gen1Y + CARD_HEIGHT + VERTICAL_SPACING;
    const gen2Groups = [];
    gen1Children.forEach(parent => {
      const children = childrenMap.get(parent.id);
      if (!children || children.length === 0) return;
      const spouseId = spouseMap.get(parent.id);
      const childSet = new Set(children);
      if (spouseId) (childrenMap.get(spouseId) || []).forEach(c => childSet.add(c));
      const groupKey = spouseId ? [parent.id, spouseId].sort().join('-') : parent.id.toString();
      if (gen2Groups.find(g => g.key === groupKey)) return;
      const childrenList = Array.from(childSet).map(id => peopleById.get(id)).filter(p => p).sort((a, b) => parseInt(a.dateOfBirth) - parseInt(b.dateOfBirth));
      gen2Groups.push({ key: groupKey, parentId: parent.id, spouseId: spouseId, children: childrenList });
    });
    let gen2TotalCards = 0;
    gen2Groups.forEach(grp => { gen2TotalCards += grp.children.length; grp.children.forEach(c => { if (spouseMap.has(c.id) && peopleById.has(spouseMap.get(c.id))) gen2TotalCards++; }); });
    const gen2Width = gen2TotalCards * CARD_WIDTH + (gen2TotalCards - 1) * SPACING + (gen2Groups.length - 1) * GROUP_SPACING;
    currentX = ANCHOR_X - (gen2Width / 2);
    gen2Groups.forEach((group, idx) => {
      const groupPositions = [];
      group.children.forEach(child => {
        const childPos = drawPersonCard(g, child, currentX, gen2Y, housesById, themeColors);
        positionMap.set(child.id, childPos);
        groupPositions.push(childPos);
        currentX += CARD_WIDTH + SPACING;
        const childSpouseId = spouseMap.get(child.id);
        if (childSpouseId && peopleById.has(childSpouseId)) {
          const spouse = peopleById.get(childSpouseId);
          const spousePos = drawPersonCard(g, spouse, currentX, gen2Y, housesById, themeColors);
          positionMap.set(childSpouseId, spousePos);
          const mc = { x: (childPos.x + childPos.width + spousePos.x) / 2, y: (childPos.y + childPos.height/2 + spousePos.y + spousePos.height/2) / 2 };
          marriageCenters.set([child.id, childSpouseId].sort().join('-'), mc);
          marriageLinesToDraw.push([childPos, spousePos]);
          currentX += CARD_WIDTH + SPACING;
        }
      });
      const mcKey = group.spouseId ? [group.parentId, group.spouseId].sort().join('-') : group.parentId.toString();
      const parentMC = marriageCenters.get(mcKey) || { x: positionMap.get(group.parentId).x + CARD_WIDTH/2, y: positionMap.get(group.parentId).y + CARD_HEIGHT };
      const isLochlann = group.parentId === 18;
      const yOffset = isLochlann ? -5 : 0;
      drawChildLines(g, parentMC, groupPositions, gen1Y + CARD_HEIGHT, gen2Y, peopleById, themeColors, yOffset, group.parentId, group.spouseId);
      if (idx < gen2Groups.length - 1) currentX += GROUP_SPACING;
    });

    // GEN 3
    const gen3Y = gen2Y + CARD_HEIGHT + VERTICAL_SPACING;
    const gen3Groups = [];
    gen2Groups.forEach(group => {
      group.children.forEach(parent => {
        const children = childrenMap.get(parent.id);
        if (!children || children.length === 0) return;
        const spouseId = spouseMap.get(parent.id);
        const childSet = new Set(children);
        if (spouseId) (childrenMap.get(spouseId) || []).forEach(c => childSet.add(c));
        const groupKey = spouseId ? [parent.id, spouseId].sort().join('-') : parent.id.toString();
        if (gen3Groups.find(g => g.key === groupKey)) return;
        const childrenList = Array.from(childSet).map(id => peopleById.get(id)).filter(p => p).sort((a, b) => parseInt(a.dateOfBirth) - parseInt(b.dateOfBirth));
        gen3Groups.push({ key: groupKey, parentId: parent.id, spouseId: spouseId, children: childrenList });
      });
    });
    let gen3TotalCards = 0;
    gen3Groups.forEach(grp => { gen3TotalCards += grp.children.length; grp.children.forEach(c => { if (spouseMap.has(c.id) && peopleById.has(spouseMap.get(c.id))) gen3TotalCards++; }); });
    const gen3Width = gen3TotalCards * CARD_WIDTH + (gen3TotalCards - 1) * SPACING + (gen3Groups.length - 1) * GROUP_SPACING;
    currentX = ANCHOR_X - (gen3Width / 2);
    gen3Groups.forEach((group, idx) => {
      const groupPositions = [];
      group.children.forEach(child => {
        const childPos = drawPersonCard(g, child, currentX, gen3Y, housesById, themeColors);
        positionMap.set(child.id, childPos);
        groupPositions.push(childPos);
        currentX += CARD_WIDTH + SPACING;
        const childSpouseId = spouseMap.get(child.id);
        if (childSpouseId && peopleById.has(childSpouseId)) {
          const spouse = peopleById.get(childSpouseId);
          const spousePos = drawPersonCard(g, spouse, currentX, gen3Y, housesById, themeColors);
          positionMap.set(childSpouseId, spousePos);
          const mc = { x: (childPos.x + childPos.width + spousePos.x) / 2, y: (childPos.y + childPos.height/2 + spousePos.y + spousePos.height/2) / 2 };
          marriageCenters.set([child.id, childSpouseId].sort().join('-'), mc);
          marriageLinesToDraw.push([childPos, spousePos]);
          currentX += CARD_WIDTH + SPACING;
        }
      });
      const mcKey = group.spouseId ? [group.parentId, group.spouseId].sort().join('-') : group.parentId.toString();
      const parentMC = marriageCenters.get(mcKey) || { x: positionMap.get(group.parentId).x + CARD_WIDTH/2, y: positionMap.get(group.parentId).y + CARD_HEIGHT };
      drawChildLines(g, parentMC, groupPositions, gen2Y + CARD_HEIGHT, gen3Y, peopleById, themeColors, 0, group.parentId, group.spouseId);
      if (idx < gen3Groups.length - 1) currentX += GROUP_SPACING;
    });

    marriageLinesToDraw.forEach(([pos1, pos2]) => drawMarriageLine(g, pos1, pos2, themeColors));
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center" style={{ backgroundColor: 'var(--bg-primary)' }}>
        <div className="text-center">
          <div className="text-4xl mb-4">⏳</div>
          <h2 className="text-2xl font-semibold mb-2" style={{ color: 'var(--text-primary)' }}>Loading Family Tree...</h2>
          <p style={{ color: 'var(--text-secondary)' }}>Fetching your genealogy data</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-screen overflow-hidden" style={{ backgroundColor: 'var(--bg-primary)' }}>
      <Navigation 
        people={people}
        onSearchResults={handleSearchResults}
        showSearch={true}
        showControlsToggle={true}
        controlsExpanded={controlsPanelExpanded}
        onToggleControls={() => setControlsPanelExpanded(!controlsPanelExpanded)}
      />

      {/* Collapsible Controls Panel */}
      <div className="fixed top-20 right-6 z-10">
        {/* Controls Panel */}
        <div
          className="rounded-lg shadow-lg transition-all duration-300 ease-in-out overflow-hidden"
          style={{
            backgroundColor: 'var(--bg-secondary)',
            borderWidth: '1px',
            borderColor: 'var(--border-primary)',
            borderRadius: 'var(--radius-lg)',
            boxShadow: 'var(--shadow-lg)',
            maxHeight: controlsPanelExpanded ? '500px' : '0',
            opacity: controlsPanelExpanded ? '1' : '0',
            padding: controlsPanelExpanded ? '1rem' : '0 1rem'
          }}
        >
          <label className="block mb-2 font-medium" style={{ color: 'var(--text-primary)' }}>View House:</label>
          <select value={selectedHouseId || ''} onChange={(e) => setSelectedHouseId(Number(e.target.value))}
            className="w-48 p-2 rounded transition"
            style={{
              backgroundColor: 'var(--bg-tertiary)',
              color: 'var(--text-primary)',
              borderWidth: '1px',
              borderColor: 'var(--border-primary)',
              borderRadius: 'var(--radius-md)'
            }}>
            {houses.map(house => (<option key={house.id} value={house.id}>{house.houseName}</option>))}
          </select>
          <div className="mt-4 pt-4" style={{ borderTopWidth: '1px', borderColor: 'var(--border-primary)' }}>
            <label className="flex items-center cursor-pointer transition-opacity hover:opacity-80" style={{ color: 'var(--text-primary)' }}>
              <input type="checkbox" checked={showCadetHouses} onChange={(e) => setShowCadetHouses(e.target.checked)} className="mr-2 w-4 h-4" />
              <span className="text-sm">Show Cadet Houses</span>
            </label>
          </div>

          <div className="mt-4 pt-4" style={{ borderTopWidth: '1px', borderColor: 'var(--border-primary)' }}>
            <label className="flex items-center cursor-pointer transition-opacity hover:opacity-80" style={{ color: 'var(--text-primary)' }}>
              <input
                type="checkbox"
                checked={showRelationships}
                onChange={(e) => {
                  const checked = e.target.checked;
                  setShowRelationships(checked);
                  showRelationshipsRef.current = checked;
                  if (!checked) {
                    setReferencePerson(null);
                    setRelationshipMap(new Map());
                  }
                }}
                className="mr-2 w-4 h-4"
              />
              <span className="text-sm">Show Relationships</span>
            </label>
            {showRelationships && referencePerson && (
              <div className="mt-2 text-xs p-2 rounded" style={{ backgroundColor: 'var(--bg-tertiary)', color: 'var(--text-secondary)' }}>
                Reference: {referencePerson.firstName} {referencePerson.lastName}
              </div>
            )}
          </div>
        </div>
      </div>

      <TreeControls svgRef={svgRef} zoomBehaviorRef={zoomBehaviorRef} showCadetHouses={showCadetHouses}
        onToggleCadetHouses={(checked) => setShowCadetHouses(checked)} zoomLevel={zoomLevel}
        onZoomChange={(level) => setZoomLevel(level)} isDarkTheme={isDarkTheme()} />

      <div className="relative w-full h-screen overflow-hidden" style={{ backgroundColor: 'var(--bg-primary)' }}>
        <svg ref={svgRef} className="tree-svg"></svg>
      </div>

      {selectedPerson && (
        <QuickEditPanel
          person={selectedPerson}
          houses={houses}
          relationships={relationships}
          people={people}
          onClose={() => setSelectedPerson(null)}
          onSave={handleQuickSave}
          onFullEdit={handleFullEdit}
          isDarkTheme={isDarkTheme()}
        />
      )}

      <style>{`
        .person-card { cursor: pointer; transition: all 0.2s ease; }
        .person-card:hover { filter: brightness(${isDarkTheme() ? '1.15' : '0.95'}); }
        .person-name { 
          font-weight: bold; 
          font-size: 13px; 
          font-family: var(--font-display), 'Georgia', serif; 
          text-shadow: 0 1px 2px rgba(0, 0, 0, ${isDarkTheme() ? '0.3' : '0.1'}); 
        }
        .person-dates { 
          font-size: 10px; 
          font-family: var(--font-body), 'Georgia', serif;
          text-shadow: 0 1px 1px rgba(0, 0, 0, ${isDarkTheme() ? '0.2' : '0.1'}); 
        }
        .person-maiden { 
          font-size: 10px; 
          font-style: italic; 
          font-family: var(--font-body), 'Georgia', serif;
          text-shadow: 0 1px 1px rgba(0, 0, 0, ${isDarkTheme() ? '0.2' : '0.1'}); 
        }
        .marriage-line { stroke-width: 2.5; fill: none; opacity: 0.8; }
        .child-line-legit { fill: none; opacity: 0.8; }
        .child-line-bastard { fill: none; opacity: 0.8; }
        .child-line-adopted { fill: none; opacity: 0.8; }
        .anchor-line { stroke-width: 1; stroke-dasharray: 5,5; opacity: 0.15; }
        .search-highlight {
          animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
      `}</style>
    </div>
  );
}

export default FamilyTree;